
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Buffer Node.js v4.1.2 Manual &amp; Documentation</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/sh.css">
    <link rel="canonical" href="buffer.html">
</head>
<body class="alt apidoc" id="api-section-buffer">
<div id="content" class="clearfix">
    <div id="column2" class="interior">
        <div id="intro" class="interior">
            <a href="index.html" title="Go back to the home page">
                Node.js (1)
            </a>
        </div>
        <ul>
            <li><a class="nav-documentation" href="documentation.html">About these Docs</a></li>
            <li><a class="nav-synopsis" href="synopsis.html">Synopsis</a></li>
            <li><a class="nav-assert" href="assert.html">Assertion Testing</a></li>
            <li><a class="nav-buffer active" href="buffer.html">Buffer</a></li>
            <li><a class="nav-addons" href="addons.html">C/C++ Addons</a></li>
            <li><a class="nav-child_process" href="child_process.html">Child Processes</a></li>
            <li><a class="nav-cluster" href="cluster.html">Cluster</a></li>
            <li><a class="nav-console" href="console.html">Console</a></li>
            <li><a class="nav-crypto" href="crypto.html">Crypto</a></li>
            <li><a class="nav-debugger" href="debugger.html">Debugger</a></li>
            <li><a class="nav-dns" href="dns.html">DNS</a></li>
            <li><a class="nav-domain" href="domain.html">Domain</a></li>
            <li><a class="nav-errors" href="errors.html">Errors</a></li>
            <li><a class="nav-events" href="events.html">Events</a></li>
            <li><a class="nav-fs" href="fs.html">File System</a></li>
            <li><a class="nav-globals" href="globals.html">Globals</a></li>
            <li><a class="nav-http" href="http.html">HTTP</a></li>
            <li><a class="nav-https" href="https.html">HTTPS</a></li>
            <li><a class="nav-modules" href="modules.html">Modules</a></li>
            <li><a class="nav-net" href="net.html">Net</a></li>
            <li><a class="nav-os" href="os.html">OS</a></li>
            <li><a class="nav-path" href="path.html">Path</a></li>
            <li><a class="nav-process" href="process.html">Process</a></li>
            <li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
            <li><a class="nav-querystring" href="querystring.html">Query Strings</a></li>
            <li><a class="nav-readline" href="readline.html">Readline</a></li>
            <li><a class="nav-repl" href="repl.html">REPL</a></li>
            <li><a class="nav-stream" href="stream.html">Stream</a></li>
            <li><a class="nav-string_decoder" href="string_decoder.html">String Decoder</a></li>
            <li><a class="nav-timers" href="timers.html">Timers</a></li>
            <li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
            <li><a class="nav-tty" href="tty.html">TTY</a></li>
            <li><a class="nav-dgram" href="dgram.html">UDP/Datagram</a></li>
            <li><a class="nav-url" href="url.html">URL</a></li>
            <li><a class="nav-util" href="util.html">Utilities</a></li>
            <li><a class="nav-v8" href="v8.html">V8</a></li>
            <li><a class="nav-vm" href="vm.html">VM</a></li>
            <li><a class="nav-zlib" href="zlib.html">ZLIB</a></li>
        </ul>

    </div>

    <div id="column1" data-id="buffer" class="interior">
        <header>
            <h1>Node.js v4.1.2 Documentation</h1>
            <div id="gtoc">
                <p>
                    <a href="index.html" name="toc">Index</a> |
                    <a href="all.html">View on single page</a> |
                    <a href="buffer.json">View as JSON</a>
                </p>
            </div>
            <hr>
        </header>

        <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#buffer_buffer">Buffer</a><ul>
                    <li><a href="#buffer_class_buffer">Class: Buffer</a><ul>
                        <li><a href="#buffer_new_buffer_size">new Buffer(size)</a></li>
                        <li><a href="#buffer_new_buffer_array">new Buffer(array)</a></li>
                        <li><a href="#buffer_new_buffer_buffer">new Buffer(buffer)</a></li>
                        <li><a href="#buffer_new_buffer_str_encoding">new Buffer(str[, encoding])</a></li>
                        <li><a href="#buffer_class_method_buffer_isencoding_encoding">Class Method: Buffer.isEncoding(encoding)</a></li>
                        <li><a href="#buffer_class_method_buffer_isbuffer_obj">Class Method: Buffer.isBuffer(obj)</a></li>
                        <li><a href="#buffer_class_method_buffer_bytelength_string_encoding">Class Method: Buffer.byteLength(string[, encoding])</a></li>
                        <li><a href="#buffer_class_method_buffer_concat_list_totallength">Class Method: Buffer.concat(list[, totalLength])</a></li>
                        <li><a href="#buffer_class_method_buffer_compare_buf1_buf2">Class Method: Buffer.compare(buf1, buf2)</a></li>
                        <li><a href="#buffer_buf_length">buf.length</a></li>
                        <li><a href="#buffer_buf_write_string_offset_length_encoding">buf.write(string[, offset][, length][, encoding])</a></li>
                        <li><a href="#buffer_buf_writeuintle_value_offset_bytelength_noassert">buf.writeUIntLE(value, offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert">buf.writeUIntBE(value, offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeintle_value_offset_bytelength_noassert">buf.writeIntLE(value, offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeintbe_value_offset_bytelength_noassert">buf.writeIntBE(value, offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuintle_offset_bytelength_noassert">buf.readUIntLE(offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuintbe_offset_bytelength_noassert">buf.readUIntBE(offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readintle_offset_bytelength_noassert">buf.readIntLE(offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readintbe_offset_bytelength_noassert">buf.readIntBE(offset, byteLength[, noAssert])</a></li>
                        <li><a href="#buffer_buf_tostring_encoding_start_end">buf.toString([encoding][, start][, end])</a></li>
                        <li><a href="#buffer_buf_tojson">buf.toJSON()</a></li>
                        <li><a href="#buffer_buf_index">buf[index]</a></li>
                        <li><a href="#buffer_buf_equals_otherbuffer">buf.equals(otherBuffer)</a></li>
                        <li><a href="#buffer_buf_compare_otherbuffer">buf.compare(otherBuffer)</a></li>
                        <li><a href="#buffer_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])</a></li>
                        <li><a href="#buffer_buf_slice_start_end">buf.slice([start[, end]])</a></li>
                        <li><a href="#buffer_buf_indexof_value_byteoffset">buf.indexOf(value[, byteOffset])</a></li>
                        <li><a href="#buffer_buf_readuint8_offset_noassert">buf.readUInt8(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuint16le_offset_noassert">buf.readUInt16LE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuint16be_offset_noassert">buf.readUInt16BE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuint32le_offset_noassert">buf.readUInt32LE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readuint32be_offset_noassert">buf.readUInt32BE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readint8_offset_noassert">buf.readInt8(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readint16le_offset_noassert">buf.readInt16LE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readint16be_offset_noassert">buf.readInt16BE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readint32le_offset_noassert">buf.readInt32LE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readint32be_offset_noassert">buf.readInt32BE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readfloatle_offset_noassert">buf.readFloatLE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readfloatbe_offset_noassert">buf.readFloatBE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readdoublele_offset_noassert">buf.readDoubleLE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_readdoublebe_offset_noassert">buf.readDoubleBE(offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuint8_value_offset_noassert">buf.writeUInt8(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuint16le_value_offset_noassert">buf.writeUInt16LE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuint16be_value_offset_noassert">buf.writeUInt16BE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuint32le_value_offset_noassert">buf.writeUInt32LE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeuint32be_value_offset_noassert">buf.writeUInt32BE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeint8_value_offset_noassert">buf.writeInt8(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeint16le_value_offset_noassert">buf.writeInt16LE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeint16be_value_offset_noassert">buf.writeInt16BE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeint32le_value_offset_noassert">buf.writeInt32LE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writeint32be_value_offset_noassert">buf.writeInt32BE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writefloatle_value_offset_noassert">buf.writeFloatLE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writefloatbe_value_offset_noassert">buf.writeFloatBE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writedoublele_value_offset_noassert">buf.writeDoubleLE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_writedoublebe_value_offset_noassert">buf.writeDoubleBE(value, offset[, noAssert])</a></li>
                        <li><a href="#buffer_buf_fill_value_offset_end">buf.fill(value[, offset][, end])</a></li>
                        <li><a href="#buffer_buffer_values">buffer.values()</a></li>
                        <li><a href="#buffer_buffer_keys">buffer.keys()</a></li>
                        <li><a href="#buffer_buffer_entries">buffer.entries()</a></li>
                    </ul>
                    </li>
                    <li><a href="#buffer_buffer_inspect_max_bytes">buffer.INSPECT_MAX_BYTES</a></li>
                    <li><a href="#buffer_es6_iteration">ES6 iteration</a></li>
                    <li><a href="#buffer_class_slowbuffer">Class: SlowBuffer</a></li>
                </ul>
                </li>
            </ul>

        </div>

        < id="apicontent">
            <h1>Buffer<span><a class="mark" href="#buffer_buffer" id="buffer_buffer">#</a></span></h1>
            <pre class="api_stability_2">Stability: 2 - Stable</pre>
            <p>纯JavaScript对Unicode友好却无法很好的处理二进制数据。
                当面对TCP流或者文件系统时，需要处理八位流
                Node.js有多种策略来操作、创建以及消费八位流

        </p>
            <p>原始数据储存在<code>Buffer</code>类的实例中. 一个 <code>Buffer</code>实例类似于一个整数数组
                但对应的是V8堆之外的一个原始内存分配区域。
                 一个<code>Buffer</code>实例大小不能改变

            </p>
            <p><code>Buffer</code>是一个全局类, 比较罕见不需要<code>require('buffer')</code>就可以使用

            </p>
            <p>Buffer和JavaScript字符串对象的转需要显式的调用编码方法，下面是一些不同的字符串编码</p>
            <ul>
                <li><p><code>&#39;ascii&#39;</code> - 仅使用于7bit的 ASCII 格式数据.  这个编码方法很高效,
                并且会剥离设置过高的bit</p>
                </li>
                <li><p><code>&#39;utf8&#39;</code> - 多字节编码Unicode字符。很多网页和文档的编码格式都是UTF-8.</p>
                </li>
                <li><p><code>&#39;utf16le&#39;</code> - 2 或者 4 字节, little endian(le低字节序)编码Unicode字符.
                    代理对 (U+10000 to U+10FFFF) 是支持的.（BE和LE表示大端和小端，Little-Endian就是低位字节排放在内存的低地址端，
                    高位字节排放在内存的高地址端；
                    Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端
                        )</p>
                </li>
                <li><p><code>&#39;ucs2&#39;</code> -<code>&#39;utf16le&#39;</code>的别名</p>
                </li>
                <li><p><code>&#39;base64&#39;</code> - Base64字符串编码</p>
                </li>
                <li><p><code>&#39;binary&#39;</code> - 一种通过只使用每个字符前八位来将原始二进制数据编码成字符串的方法。
                    这种编码方法是不赞成使用的，尽量避免使用，应用 <code>Buffer</code>对象来代替。这个编码方法将会在未来版本的Node.js中被移除。
                </p>
                </li>
                <li><p><code>&#39;hex&#39;</code> - 把每个字节编码成2个十六进制字符</p>
                </li>
            </ul>
            <p>通过一个<code>Buffer</code>来创建一个类型化的数组需要注意以下事项：

            </p>
            <ol>
                <li><p>buffer的内存空间是复制的，而不是共享的。</p>
                </li>
                <li><p>buffer的字符空间被解读成数组,不是一个字节数组.  也就是说,
                    <code>new Uint32Array(new Buffer([1,2,3,4]))</code> 创建了一个拥有4个元素的<code>Uint32Array</code>
                    并且元素为<code>[1,2,3,4]</code>, 而不是只有一个元素为<code>[0x1020304]</code> 或者 <code>[0x4030201]</code>的<code>Uint32Array</code>
                    </p>
                </li>
            </ol>
            <p>注意: Node.js v0.8 仅仅简单的保存了buffer在<code>array.buffer</code>中的引用，
                而不是克隆它。
            </p>
        <p>而更有效率的，它与类型化数组有着微妙的不同。当<code>Buffer#slice()</code>创建一个视图时，
            <code>ArrayBuffer#slice()</code>会生成一个切片多的副本</p>
            <h2>Class: Buffer<span><a class="mark" href="#buffer_class_buffer" id="buffer_class_buffer">#</a></span></h2>
            <p>Buffer类是全局类型，并且可以直接处理二进制数据。可以通过多种方式构造它。
            </p>
            <h3>new Buffer(size)<span><a class="mark" href="#buffer_new_buffer_size" id="buffer_new_buffer_size">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>size</code> Number</li>
            </div></ul>
        <p>
            新分配一个大小为<code>size</code>的buffer。在32位机上，<code>size</code>大小必须小于1,073,741,824 bytes (1 GB)，
            64位机上，必须小于2,147,483,648 bytes (2 GB)，否则将抛出<code>RangeError</code>异常
        </p>
        <p>与<code>ArrayBuffers</code>不同, 下面的几个构造函数并不会初始化buffer的内存空间。
            所以新创建的<code>Buffer</code>的内容是不确定的并且可能包含敏感数据
            。使用<code>buf.fill(0)</code>来将buffer大小初始化为0.

        </p>
            <h3>new Buffer(array)<span><a class="mark" href="#buffer_new_buffer_array" id="buffer_new_buffer_array">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>array</code> Array</li>
            </div></ul>
            <p>Allocates a new buffer using an <code>array</code> of octets.

            </p>
        <p>使用8位字节<code>array</code>来分配一个新的buffer.

        </p>
            <h3>new Buffer(buffer)<span><a class="mark" href="#buffer_new_buffer_buffer" id="buffer_new_buffer_buffer">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>buffer</code> <span class="type">Buffer</span></li>
            </div></ul>
        <p>复制已验证的buffer到一个新的<code>Buffer</code>实例

        </p>
            <h3>new Buffer(str[, encoding])<span><a class="mark" href="#buffer_new_buffer_str_encoding" id="buffer_new_buffer_str_encoding">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>str</code> String - 需要存入buffer的string字符串.</li>
                <li><code>encoding</code> String - 编码方式, 可选.</li>
            </div></ul>
        <p>创建一个包含<code>str</code>的新buffer。编码方式为<code>encoding</code>，默认是<code>&#39;utf8&#39;</code>
        </p>
            <h3>Class Method: Buffer.isEncoding(encoding)<span><a class="mark" href="#buffer_class_method_buffer_isencoding_encoding" id="buffer_class_method_buffer_isencoding_encoding">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>encoding</code> <span class="type">String</span>用来测试给定的编码字符串</li>
            </div></ul>
        <p>当<code>encoding</code>是有效的，返回true，否则返回false
        </p>
            <h3>Class Method: Buffer.isBuffer(obj)<span><a class="mark" href="#buffer_class_method_buffer_isbuffer_obj" id="buffer_class_method_buffer_isbuffer_obj">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>obj</code> Object</li>
                <li>Return: Boolean</li>
            </div></ul>
            <p>测试<code>obj</code>是否为<code>Buffer</code>.

            </p>
            <h3>Class Method: Buffer.byteLength(string[, encoding])<span><a class="mark" href="#buffer_class_method_buffer_bytelength_string_encoding" id="buffer_class_method_buffer_bytelength_string_encoding">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>string</code> String</li>
                <li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
                <li>Return: Number</li>
            </div></ul>
        <p>返回一个字符串的真实字节长度(byte)。<code>encoding</code>默认为<code>&#39;utf8&#39;</code>.
            它与<code>String.prototype.length</code>是不一样的，<code>String.prototype.length</code>返回的是一个字符串的
            字符数(characters)
        </p>
            <p>Example:

            </p>
<pre><code>str = &#39;\u00bd + \u00bc = \u00be&#39;;

    console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +
    Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);

    // ½ + ¼ = ¾: 9 characters,  12 bytes</code></pre>
            <h3>Class Method: Buffer.concat(list[, totalLength])<span><a class="mark" href="#buffer_class_method_buffer_concat_list_totallength" id="buffer_class_method_buffer_concat_list_totallength">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>list</code> <span class="type">Array</span> 需要合并的Buffer对象列表</li>
                <li><code>totalLength</code> <span class="type">Number</span>所有buffer的大小总和</li>
            </div></ul>
            <p>
                返回一个合并好的buffer对象
            </p>
            <p>如果list为空, 或者totalLength为0,那么返回一个大小为0的buffer.

            </p>
        <p>如果没有提供totalLength参数, 将会从list中的buffer计算读取。
            然而,会增加一个额外的循环来计算它，所以提供一个明确的totalLength参数将会快很多
        </p>

            <h3>Class Method: Buffer.compare(buf1, buf2)<span><a class="mark" href="#buffer_class_method_buffer_compare_buf1_buf2" id="buffer_class_method_buffer_compare_buf1_buf2">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>buf1</code> <span class="type">Buffer</span></li>
                <li><code>buf2</code> <span class="type">Buffer</span></li>
            </div></ul>
            <p>与<a href="#buffer_buf_compare_otherbuffer"><code>buf1.compare(buf2)</code></a>相同。
                在对Buffer数组排序时很有用
            </p>
<pre><code>
    var arr = [Buffer(&#39;1234&#39;), Buffer(&#39;0123&#39;)];
    arr.sort(Buffer.compare);
    //[ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]
</code></pre>
            <h3>buf.length<span><a class="mark" href="#buffer_buf_length" id="buffer_buf_length">#</a></span></h3>
            <div class="signature"><ul>
                <li>Number</li>
            </div></ul>
        <p>buffer中字节数(bytes)大小。注意这不一定是buffer所含内容的大小。
            <code>length</code>表示给buffer对象分配的内存大小，当buffer内容改变时，此大小不会改变
        </p>
<pre><code>buf = new Buffer(1234);

    console.log(buf.length);
    buf.write(&quot;some string&quot;, 0, &quot;ascii&quot;);
    console.log(buf.length);

    // 1234
    // 1234</code></pre>
            <p>当<code>length</code>属性不可变时，改变<code>length</code>的值将会引起undefined和不一致行为。
                若在应用程序中想要改变buffer的大小，则应该把 <code>length</code>属性看做只读的，并且使用
                <code>buf.slice</code>来创建一个新的buffer
            </p>
<pre><code>buf = new Buffer(10);
    buf.write(&quot;abcdefghj&quot;, 0, &quot;ascii&quot;);
    console.log(buf.length); // 10
    buf = buf.slice(0,5);
    console.log(buf.length); // 5</code></pre>
            <h3>buf.write(string[, offset][, length][, encoding])<span><a class="mark" href="#buffer_buf_write_string_offset_length_encoding" id="buffer_buf_write_string_offset_length_encoding">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>string</code> String - data to be written to buffer</li>
                <li><code>offset</code> Number, Optional, Default: 0</li>
                <li><code>length</code> Number, Optional, Default: <code>buffer.length - offset</code></li>
                <li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
            </div></ul>
            <p>根据给定的编码方式在偏移量<code>offset</code>处写入<code>string</code>到buffer
                <code>offset</code>默认为<code>0</code>, <code>encoding</code>默认为<code>&#39;utf8&#39;</code>. <code>length</code>
                是写入字符串的字节大小。返回已写入的八位字节流. If <code>buffer</code>
                没有足够的空间来存放整个字符串, 那么将会写入字符串的一部分。
                <code>length</code>默认为<code>buffer.length - offset</code>.
                这个方法不会写入部分字符

            </p>
<pre><code>buf = new Buffer(256);
    len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);
    console.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));</code></pre>
            <h3>buf.writeUIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintle_value_offset_bytelength_noassert" id="buffer_buf_writeuintle_value_offset_bytelength_noassert">#</a></span></h3>
            <h3>buf.writeUIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeuintbe_value_offset_bytelength_noassert" id="buffer_buf_writeuintbe_value_offset_bytelength_noassert">#</a></span></h3>
            <h3>buf.writeIntLE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintle_value_offset_bytelength_noassert" id="buffer_buf_writeintle_value_offset_bytelength_noassert">#</a></span></h3>
            <h3>buf.writeIntBE(value, offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_writeintbe_value_offset_bytelength_noassert" id="buffer_buf_writeintbe_value_offset_bytelength_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> {Number}将要写入到buffer中的字节</li>
                <li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length</code></li>
                <li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
                <li><code>noAssert</code> {Boolean} Default: false</li>
                <li>Return: {Number}</li>
            </ul>
            <p>根据指定的<code>offset</code>和 <code>byteLength</code>参数，将<code>value</code>写入到buffer中，
                一次最多写入48位(bits)
            </p>

<pre><code>var b = new Buffer(6);
    b.writeUIntBE(0x1234567890ab, 0, 6);
    // &lt;Buffer 12 34 56 78 90 ab&gt;</code></pre>
        <p>将<code>noAssert</code>设置为<code>true</code>来跳过<code>value</code>
            和 <code>offset</code>的校验。 默认为 <code>false</code>.
        </p>

            <h3>buf.readUIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintle_offset_bytelength_noassert" id="buffer_buf_readuintle_offset_bytelength_noassert">#</a></span></h3>

        <h3>buf.readUIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readuintbe_offset_bytelength_noassert" id="buffer_buf_readuintbe_offset_bytelength_noassert">#</a></span></h3>
            <h3>buf.readIntLE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintle_offset_bytelength_noassert" id="buffer_buf_readintle_offset_bytelength_noassert">#</a></span></h3>
            <h3>buf.readIntBE(offset, byteLength[, noAssert])<span><a class="mark" href="#buffer_buf_readintbe_offset_bytelength_noassert" id="buffer_buf_readintbe_offset_bytelength_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> {Number} <code>0 &lt;= offset &lt;= buf.length</code></li>
                <li><code>byteLength</code> {Number} <code>0 &lt; byteLength &lt;= 6</code></li>
                <li><code>noAssert</code> {Boolean} Default: false</li>
                <li>Return: {Number}</li>
            </ul>
        <p>一个读取数字方法的通用版本。最大支持48位。 例:

        </p>
<pre><code>var b = new Buffer(6);
    b.writeUint16LE(0x90ab, 0);
    b.writeUInt32LE(0x12345678, 2);
    b.readUIntLE(0, 6).toString(16);  // Specify 6 bytes (48 bits)
    // output: &#39;1234567890ab&#39;</code></pre>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>

            <h3>buf.toString([encoding][, start][, end])<span><a class="mark" href="#buffer_buf_tostring_encoding_start_end" id="buffer_buf_tostring_encoding_start_end">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>encoding</code> String, Optional, Default: &#39;utf8&#39;</li>
                <li><code>start</code> Number, Optional, Default: 0</li>
                <li><code>end</code> Number, Optional, Default: <code>buffer.length</code></li>
            </div></ul>
        <p>解码经过特定字符集<code>encoding</code>编码过后的流数据，并返回。
            如果<code>encoding</code> 为 <code>undefined</code> 或者为 <code>null</code>, 那么 <code>encoding</code>
            则默认为 <code>&#39;utf8&#39;</code>。<code>start</code> 和 <code>end</code> 参数 默认为 <code>0</code> 和
            <code>buffer.length</code>(当他们为<code>undefined</code>时)

        </p>
<pre><code>buf = new Buffer(26);
    for (var i = 0 ; i &lt; 26 ; i++) {
    buf[i] = i + 97; // 97 is ASCII a
    }
    buf.toString(&#39;ascii&#39;); // outputs: abcdefghijklmnopqrstuvwxyz
    buf.toString(&#39;ascii&#39;,0,5); // outputs: abcde
    buf.toString(&#39;utf8&#39;,0,5); // outputs: abcde
    buf.toString(undefined,0,5); // encoding defaults to &#39;utf8&#39;, outputs abcde</code></pre>
            <p>见上面的<code>buffer.write()</code>例子。


            </p>
            <h3>buf.toJSON()<span><a class="mark" href="#buffer_buf_tojson" id="buffer_buf_tojson">#</a></span></h3>
        <p>返回一个Buffer实例的JSON形式。
            <code>JSON.stringify</code>方法隐式的调用此函数，当字符串化一个Buffer实例时
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(&#39;test&#39;);
    var json = JSON.stringify(buf);

    console.log(json);
    // &#39;{&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[116,101,115,116]}&#39;

    var copy = JSON.parse(json, function(key, value) {
    return value &amp;&amp; value.type === &#39;Buffer&#39;
    ? new Buffer(value.data)
    : value;
    });

    console.log(copy);
    // &lt;Buffer 74 65 73 74&gt;</code></pre>
            <h3>buf[index]<span><a class="mark" href="#buffer_buf_index" id="buffer_buf_index">#</a></span></h3>
            <!--type=property-->
            <!--name=[index]-->

            <p>设置或者获取在索引<code>index</code>位置的8位字节。 这个值指的是单个字节,
                所以合法的范围是在<code>0x00</code> and <code>0xFF</code> 16进制 或 <code>0</code> and <code>255</code>10进制之间
            </p>
            <p>Example: 复制一个ASCII字符串到buffer，每次一个字节：

            </p>
<pre><code>str = &quot;Node.js&quot;;
    buf = new Buffer(str.length);

    for (var i = 0; i &lt; str.length ; i++) {
    buf[i] = str.charCodeAt(i);
    }

    console.log(buf);

    // Node.js</code></pre>
            <h3>buf.equals(otherBuffer)<span><a class="mark" href="#buffer_buf_equals_otherbuffer" id="buffer_buf_equals_otherbuffer">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>otherBuffer</code> <span class="type">Buffer</span></li>
            </div></ul>
            <p>当<code>this</code> 和 <code>otherBuffer</code> 拥有相同的字节内容时，返回真

            </p>
            <h3>buf.compare(otherBuffer)<span><a class="mark" href="#buffer_buf_compare_otherbuffer" id="buffer_buf_compare_otherbuffer">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>otherBuffer</code> <span class="type">Buffer</span></li>
            </div></ul>
        <p>返回一个数字，表明在排序顺序中<code>this</code>在<code>otherBuffer</code>之前、之后、还是相同的</p>
            <h3>buf.copy(targetBuffer[, targetStart][, sourceStart][, sourceEnd])<span><a class="mark" href="#buffer_buf_copy_targetbuffer_targetstart_sourcestart_sourceend" id="buffer_buf_copy_targetbuffer_targetstart_sourcestart_sourceend">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>targetBuffer</code> Buffer object - 目标Buffer</li>
                <li><code>targetStart</code> Number, 可选, 默认为0</li>
                <li><code>sourceStart</code> Number, 可选, 默认为0</li>
                <li><code>sourceEnd</code> Number, 可选, 默认为: <code>buffer.length</code></li>
            </div></ul>
        <p>复制当前buffer的一部分数据到到目标buffer的一个区域即使目标buffer的内存区域数据与此数据重复。
            若其余参数为<code>undefined</code>(没有给出),那么将默认设置为<code>0</code>,
            <code>sourceEnd</code>默认为<code>buffer.length</code>.

        </p>
            <p>Example:创建两个buffer，复制<code>buf1</code>的16字节到19字节的数据到<code>buf2</code>，
                并且从<code>buf2</code>的第八位开始
            </p>
<pre><code>buf1 = new Buffer(26);
    buf2 = new Buffer(26);

    for (var i = 0 ; i &lt; 26 ; i++) {
    buf1[i] = i + 97; // 97 is ASCII a
    buf2[i] = 33; // ASCII !
    }

    buf1.copy(buf2, 8, 16, 20);
    console.log(buf2.toString(&#39;ascii&#39;, 0, 25));

    // !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>
            <p>Example:创建一个buffer，复制一部分内存区域的数据到有相同数据的重叠区域
            </p>
<pre><code>buf = new Buffer(26);

    for (var i = 0 ; i &lt; 26 ; i++) {
    buf[i] = i + 97; // 97 is ASCII a
    }

    buf.copy(buf, 0, 4, 10);
    console.log(buf.toString());

    // efghijghijklmnopqrstuvwxyz</code></pre>
            <h3>buf.slice([start[, end]])<span><a class="mark" href="#buffer_buf_slice_start_end" id="buffer_buf_slice_start_end">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>start</code> Number, Optional, Default: 0</li>
                <li><code>end</code> Number, Optional, Default: <code>buffer.length</code></li>
            </div></ul>
        <p>返回一个新的buffer并且和原始的buffer指向相同的内存区域,
            但偏移量和裁剪过后的受<code>start</code> (默认为 <code>0</code>) 和 <code>end</code> (默认<code>buffer.length</code>)调控。
            负数索引从buffer开始
        </p>
        <p><strong>修改新buffer切片将会影响到的原始buffer的数据！！</strong>

        </p>

        <p>Example: 用ASCII字母表创建一个buffer, 获取一个切片, 然后从原始
            buffer修改一个字节

        </p>

<pre><code>var buf1 = new Buffer(26);

    for (var i = 0 ; i &lt; 26 ; i++) {
    buf1[i] = i + 97; // 97 is ASCII a
    }

    var buf2 = buf1.slice(0, 3);
    console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));
    buf1[0] = 33;
    console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));

    // abc
    // !bc</code></pre>
            <h3>buf.indexOf(value[, byteOffset])<span><a class="mark" href="#buffer_buf_indexof_value_byteoffset" id="buffer_buf_indexof_value_byteoffset">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>value</code> String, Buffer or Number</li>
                <li><code>byteOffset</code> Number, Optional, Default: 0</li>
                <li>Return: Number</li>
            </div></ul>
        <p>与
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf">Array#indexOf()</a>的操作相类似。
            接受字符串、Buffer或者数字。字符串解释成UTF8。
            Buffers will use the entire buffer. So in order to compare a partial Buffer use
            <code>Buffer#slice()</code>. Numbers can range from 0 to 255.

        </p>
            <h3>buf.readUInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint8_offset_noassert" id="buffer_buf_readuint8_offset_noassert">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </div></ul>
        <p>从buffer的指定偏移量处读取一个无符号8位整数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);

    buf[0] = 0x3;
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;

    for (ii = 0; ii &lt; buf.length; ii++) {
    console.log(buf.readUInt8(ii));
    }

    // 0x3
    // 0x4
    // 0x23
    // 0x42</code></pre>
            <h3>buf.readUInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16le_offset_noassert" id="buffer_buf_readuint16le_offset_noassert">#</a></span></h3>
            <h3>buf.readUInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint16be_offset_noassert" id="buffer_buf_readuint16be_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
        <p>以指定的字节序从buffer的指定偏移量处读取一个无符号16位整数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);

    buf[0] = 0x3;
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;

    console.log(buf.readUInt16BE(0));
    console.log(buf.readUInt16LE(0));
    console.log(buf.readUInt16BE(1));
    console.log(buf.readUInt16LE(1));
    console.log(buf.readUInt16BE(2));
    console.log(buf.readUInt16LE(2));

    // 0x0304
    // 0x0403
    // 0x0423
    // 0x2304
    // 0x2342
    // 0x4223</code></pre>
            <h3>buf.readUInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32le_offset_noassert" id="buffer_buf_readuint32le_offset_noassert">#</a></span></h3>
            <h3>buf.readUInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readuint32be_offset_noassert" id="buffer_buf_readuint32be_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
        <p>以指定的字节序从buffer的指定偏移量处读取一个无符号32位整数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);

    buf[0] = 0x3;
    buf[1] = 0x4;
    buf[2] = 0x23;
    buf[3] = 0x42;

    console.log(buf.readUInt32BE(0));
    console.log(buf.readUInt32LE(0));

    // 0x03042342
    // 0x42230403</code></pre>
            <h3>buf.readInt8(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint8_offset_noassert" id="buffer_buf_readint8_offset_noassert">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </div></ul>
        <p>从buffer的指定偏移量处读取一个有符号8位整数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
        <p>与<code>buffer.readUInt8</code>的工作原理相同, 除了buffer的内容被当成是二进制补码有符号的值以外

        </p>
            <h3>buf.readInt16LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16le_offset_noassert" id="buffer_buf_readint16le_offset_noassert">#</a></span></h3>
            <h3>buf.readInt16BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint16be_offset_noassert" id="buffer_buf_readint16be_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
            <p>以指定的字节序从buffer的指定偏移量处读取一个有符号16位整数

            </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
        <p>与<code>buffer.readUInt16*</code>的工作原理相同, 除了buffer的内容被当成是二进制补码有符号的值以外

        </p>
            <h3>buf.readInt32LE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32le_offset_noassert" id="buffer_buf_readint32le_offset_noassert">#</a></span></h3>
            <h3>buf.readInt32BE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readint32be_offset_noassert" id="buffer_buf_readint32be_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
        <p>以指定的字节序从buffer的指定偏移量处读取一个有符号32位整数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
        <p>与<code>buffer.readUInt32*</code>的工作原理相同, 除了buffer的内容被当成是二进制补码有符号的值以外

        </p>
            <h3>buf.readFloatLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatle_offset_noassert" id="buffer_buf_readfloatle_offset_noassert">#</a></span></h3>
            <h3>buf.readFloatBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readfloatbe_offset_noassert" id="buffer_buf_readfloatbe_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
        <p>以指定的字节序从buffer中的指定偏移量处读取一个32位的浮点数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);

    buf[0] = 0x00;
    buf[1] = 0x00;
    buf[2] = 0x80;
    buf[3] = 0x3f;

    console.log(buf.readFloatLE(0));

    // 0x01</code></pre>
            <h3>buf.readDoubleLE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublele_offset_noassert" id="buffer_buf_readdoublele_offset_noassert">#</a></span></h3>
            <h3>buf.readDoubleBE(offset[, noAssert])<span><a class="mark" href="#buffer_buf_readdoublebe_offset_noassert" id="buffer_buf_readdoublebe_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
                <li>Return: Number</li>
            </ul>
        <p>以指定的字节序从buffer中的指定偏移量处读取一个64位的浮点数

        </p>
        <p>设置<code>noAssert</code>为true来跳过对<code>offset</code>的验证。
            这意味着偏移量<code>offset</code>可能会超出buffer的界限。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(8);

    buf[0] = 0x55;
    buf[1] = 0x55;
    buf[2] = 0x55;
    buf[3] = 0x55;
    buf[4] = 0x55;
    buf[5] = 0x55;
    buf[6] = 0xd5;
    buf[7] = 0x3f;

    console.log(buf.readDoubleLE(0));

    // 0.3333333333333333</code></pre>
            <h3>buf.writeUInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint8_value_offset_noassert" id="buffer_buf_writeuint8_value_offset_noassert">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </div></ul>
            <p>在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
               无符号8位整数。

            </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
            </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);
    buf.writeUInt8(0x3, 0);
    buf.writeUInt8(0x4, 1);
    buf.writeUInt8(0x23, 2);
    buf.writeUInt8(0x42, 3);

    console.log(buf);

    // &lt;Buffer 03 04 23 42&gt;</code></pre>
            <h3>buf.writeUInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16le_value_offset_noassert" id="buffer_buf_writeuint16le_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeUInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint16be_value_offset_noassert" id="buffer_buf_writeuint16be_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
        <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
            无符号16位整数。

        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);
    buf.writeUInt16BE(0xdead, 0);
    buf.writeUInt16BE(0xbeef, 2);

    console.log(buf);

    buf.writeUInt16LE(0xdead, 0);
    buf.writeUInt16LE(0xbeef, 2);

    console.log(buf);

    // &lt;Buffer de ad be ef&gt;
    // &lt;Buffer ad de ef be&gt;</code></pre>
            <h3>buf.writeUInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32le_value_offset_noassert" id="buffer_buf_writeuint32le_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeUInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeuint32be_value_offset_noassert" id="buffer_buf_writeuint32be_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
        <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
            无符号32位整数。

        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);
    buf.writeUInt32BE(0xfeedface, 0);

    console.log(buf);

    buf.writeUInt32LE(0xfeedface, 0);

    console.log(buf);

    // &lt;Buffer fe ed fa ce&gt;
    // &lt;Buffer ce fa ed fe&gt;</code></pre>
            <h3>buf.writeInt8(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint8_value_offset_noassert" id="buffer_buf_writeint8_value_offset_noassert">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </div></ul>
        <p>在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
            有符号8位整数。
        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
            <p>与<code>buffer.writeUInt8</code>工作原理相同, 但它是作为一个二进制补码有符号整数写入<code>buffer</code>中的。

            </p>
            <h3>buf.writeInt16LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16le_value_offset_noassert" id="buffer_buf_writeint16le_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeInt16BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint16be_value_offset_noassert" id="buffer_buf_writeint16be_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
        <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
            有符号16位整数。
        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
        <p>与<code>buffer.writeUInt16*</code>工作原理相同, 但它是作为一个二进制补码有符号整数写入<code>buffer</code>中的。

        </p>
            <h3>buf.writeInt32LE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32le_value_offset_noassert" id="buffer_buf_writeint32le_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeInt32BE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writeint32be_value_offset_noassert" id="buffer_buf_writeint32be_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
        <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的
            有符号32位整数。
        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
        <p>与<code>buffer.writeUInt32*</code>工作原理相同, 但它是作为一个二进制补码有符号整数写入<code>buffer</code>中的。

        </p>
            <h3>buf.writeFloatLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatle_value_offset_noassert" id="buffer_buf_writefloatle_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeFloatBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writefloatbe_value_offset_noassert" id="buffer_buf_writefloatbe_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
        <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, 并未指明<code>value</code>一定是32位浮点数
        </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(4);
    buf.writeFloatBE(0xcafebabe, 0);

    console.log(buf);

    buf.writeFloatLE(0xcafebabe, 0);

    console.log(buf);

    // &lt;Buffer 4f 4a fe bb&gt;
    // &lt;Buffer bb fe 4a 4f&gt;</code></pre>
            <h3>buf.writeDoubleLE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublele_value_offset_noassert" id="buffer_buf_writedoublele_value_offset_noassert">#</a></span></h3>
            <h3>buf.writeDoubleBE(value, offset[, noAssert])<span><a class="mark" href="#buffer_buf_writedoublebe_value_offset_noassert" id="buffer_buf_writedoublebe_value_offset_noassert">#</a></span></h3>
            <ul>
                <li><code>value</code> Number</li>
                <li><code>offset</code> Number</li>
                <li><code>noAssert</code> Boolean, Optional, Default: false</li>
            </ul>
            <p>以指定的字节序在给定的偏移量处将<code>value</code>写入到buffer中。 注意, <code>value</code>必须是合法的64位浮点数
            </p>
        <p>将<code>noAssert</code>设置为真来跳过对<code>value</code> 和 <code>offset</code>的验证。
            这意味着对指定的方法来说value可能太大并且<code>offset</code>可能超过buffer末尾导致value被丢弃。
            除非你非常有把握，否则不要使用它。默认设置为<code>false</code>
        </p>
            <p>Example:

            </p>
<pre><code>var buf = new Buffer(8);
    buf.writeDoubleBE(0xdeadbeefcafebabe, 0);

    console.log(buf);

    buf.writeDoubleLE(0xdeadbeefcafebabe, 0);

    console.log(buf);

    // &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;
    // &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>
            <h3>buf.fill(value[, offset][, end])<span><a class="mark" href="#buffer_buf_fill_value_offset_end" id="buffer_buf_fill_value_offset_end">#</a></span></h3>
            <div class="signature"><ul>
                <li><code>value</code></li>
                <li><code>offset</code> Number, Optional</li>
                <li><code>end</code> Number, Optional</li>
            </div></ul>
        <p>使用给定的value来填充buffer。若<code>offset</code>(默认为<code>0</code>)和<code>end</code>(默认为<code>buffer.length</code>)
        没有给出，那么将会填充整个buffer
        </p>
<pre><code>var b = new Buffer(50);
    b.fill(&quot;h&quot;);</code></pre>
            <h3>buffer.values()<span><a class="mark" href="#buffer_buffer_values" id="buffer_buffer_values">#</a></span></h3>
        <p>创建一个迭代buffer值(bytes)的迭代器。当<code>buffer</code>使用<code>for .. of</code>语句时，这个函数将会自动调用</p>
            <h3>buffer.keys()<span><a class="mark" href="#buffer_buffer_keys" id="buffer_buffer_keys">#</a></span></h3>
            <p>为buffer keys(索引)创建一个迭代器
            </p>
            <h3>buffer.entries()<span><a class="mark" href="#buffer_buffer_entries" id="buffer_buffer_entries">#</a></span></h3>
            <p>创建<code>[index, byte]</code>数组的迭代器
            </p>
            <h2>buffer.INSPECT_MAX_BYTES<span><a class="mark" href="#buffer_buffer_inspect_max_bytes" id="buffer_buffer_inspect_max_bytes">#</a></span></h2>
            <div class="signature"><ul>
                <li>Number, Default: 50</li>
            </div></ul>
        <p>当<code>buffer.inspect()</code>被调用时将会返回多少字节。这个函数可以被用户自定义模块重写</p>
        <p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can
                be overridden by user modules.

            </p>
        <p>注意，这是通过<code>require(&#39;buffer&#39;)</code>返回的buffer模块的一个属性，并不是全局的Buffer，也不是一个buffer实例</p>
            <p>Note that this is a property on the buffer module returned by
                <code>require(&#39;buffer&#39;)</code>, not on the Buffer global, or a buffer instance.

            </p>
            <h2>ES6 iteration<span><a class="mark" href="#buffer_es6_iteration" id="buffer_es6_iteration">#</a></span></h2>
            <p>
                Buffers可以通过<code>for..of</code>语句来迭代:
            </p>
<pre><code>var buf = new Buffer([1, 2, 3]);

    for (var b of buf)
    console.log(b)

    // 1
    // 2
    // 3</code></pre>
            <p>
                除此之外，<code>buffer.values()</code>, <code>buffer.keys()</code> and <code>buffer.entries()</code>
                都可以用来创建迭代器
            </p>
            <h2>Class: SlowBuffer<span><a class="mark" href="#buffer_class_slowbuffer" id="buffer_class_slowbuffer">#</a></span></h2>
            <p>返回一个不被池管理的<code>Buffer</code>.

            </p>
            <p>为了避免大量独立分配的buffer所带来的垃圾回收开销，默认情况下少于4KB
                的空间都是切割自一个较大的独立对象。这种策略既提高了性能也改善了内存使用，
                因为 V8 不需要跟踪和清理很多 <code>Persistent</code>对象。</p>
            <p>
                当开发者需要将池中一小块数据保留不确定的一段时间，较为妥当的办法是用 SlowBuffer
                创建一个不被池管理的 Buffer 实例并将相应数据拷贝出来。
            </p>
<pre><code>// need to keep around a few small chunks of memory
    var store = [];

    socket.on(&#39;readable&#39;, function() {
    var data = socket.read();
    // allocate for retained data
    var sb = new SlowBuffer(10);
    // copy the data into the new allocation
    data.copy(sb, 0, 0, 10);
    store.push(sb);
    });</code></pre>
            <p>请谨慎使用，仅作为开发者频繁观察到他们的应用中过度的内存保留时的最后手段。
            </p>

        </div>
    </div>
</div>
<div id="footer">
</div>

<script src="assets/sh_main.js"></script>
<script src="assets/sh_javascript.min.js"></script>
<script>highlight(undefined, undefined, 'pre');</script>
</body>
</html>

